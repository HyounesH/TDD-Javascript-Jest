"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DiffDOM = require("diff-dom");
var stableSort = require("lodash.sortby");
var dd = new DiffDOM();
function splitReplaceDiff(diff) {
    if (diff.action !== 'replaceElement') {
        return [diff];
    }
    if (!isWildcardComment(diff.oldValue)) {
        return [diff];
    }
    var removeDiff = {
        action: 'removeElement',
        route: diff.route,
        element: diff.oldValue,
    };
    var addDiff = {
        action: 'addElement',
        route: diff.route,
        element: diff.newValue,
    };
    return [removeDiff, addDiff];
}
function areRoutesAdjacent(diffA, diffB) {
    var routeA = diffA.route.join('');
    var routeB = diffB.route.join('');
    var prefixA = routeA.substring(0, routeA.length - 1);
    var prefixB = routeB.substring(0, routeB.length - 1);
    var lastA = diffA.route[diffA.route.length - 1];
    var lastB = diffB.route[diffB.route.length - 1];
    return routeA.length === routeB.length
        && prefixA === prefixB
        && (lastA === lastB || lastA + 1 === lastB);
}
function groupByWildcard(groups, diff, index, diffs) {
    var group = groups[groups.length - 1];
    var firstInGroup = group[0];
    var lastInGroup = group[group.length - 1];
    if (firstInGroup
        && isRemoveWildcardDiff(firstInGroup)
        && lastInGroup
        && areRoutesAdjacent(lastInGroup, diff)
        && isAddSomethingDiff(diff)) {
        group.push(diff);
    }
    else {
        groups.push([diff]);
    }
    return groups;
}
function isAddAttribute(diff) {
    return diff.action === 'addAttribute';
}
function isWildcardComment(element) {
    return element.nodeName === '#comment'
        && element.data.trim() === '$ignored-wildcard-element$';
}
function isRemoveWildcardDiff(diff) {
    return diff.action === 'removeElement' && isWildcardComment(diff.element);
}
function isAddElementDiff(diff) {
    return diff.action === 'addElement';
}
function isAddTextElementDiff(diff) {
    return diff.action === 'addTextElement';
}
function isAddSomethingDiff(diff) {
    return isAddElementDiff(diff) || isAddTextElementDiff(diff);
}
function makeDiff(actualDoc, expectedDoc) {
    var diffs1 = dd.diff(expectedDoc, actualDoc);
    var diffs2 = stableSort(diffs1, function (d) { return d.route.join(''); });
    var diffs = diffs2
        .map(splitReplaceDiff)
        .reduce(function (a, b) { return a.concat(b); }, [])
        .filter(function (d) { return !isAddAttribute(d); })
        .reduce(groupByWildcard, [[]])
        .filter(function (group) { return group.length > 0 && !isRemoveWildcardDiff(group[0]); })
        .reduce(function (a, b) { return a.concat(b); }, []);
    return diffs;
}
exports.makeDiff = makeDiff;
//# sourceMappingURL=diff.js.map