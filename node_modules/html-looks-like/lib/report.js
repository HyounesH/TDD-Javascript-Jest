"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function routeToNode(doc, route) {
    var ref = doc;
    route.forEach(function (i) {
        ref = ref.childNodes[i];
    });
    return ref;
}
function serializeTextNodeObj(nodeObj) {
    return nodeObj.data;
}
function serializeCommentNodeObj(nodeObj) {
    return "<!--" + nodeObj.data + "-->";
}
function serializeElementNodeObj(nodeObj) {
    if (typeof nodeObj.attributes === 'undefined') {
        nodeObj.attributes = {};
    }
    if (typeof nodeObj.childNodes === 'undefined') {
        nodeObj.childNodes = [];
    }
    var tagName = nodeObj.nodeName.toLowerCase();
    var attrs = Object.keys(nodeObj.attributes)
        .map(function (name) { return name + "=\"" + nodeObj.attributes[name] + "\""; });
    var head = [tagName].concat(attrs).join(' ');
    var children = nodeObj.childNodes.map(serializeNodeObj).join('');
    return "<" + head + ">" + children + "</" + tagName + ">";
}
function serializeNodeObj(nodeObj) {
    if (nodeObj.nodeName === '#text') {
        return serializeTextNodeObj(nodeObj);
    }
    else if (nodeObj.nodeName === '#comment') {
        return serializeCommentNodeObj(nodeObj);
    }
    else if (nodeObj.nodeName[0] !== '#') {
        return serializeElementNodeObj(nodeObj);
    }
    else {
        return "serializeNodeObj(" + JSON.stringify(nodeObj) + ")";
    }
}
function mdHTML(html) {
    return '```html\n' + html + '\n```';
}
function renderMismatch(diff, actualDoc, expectedDoc) {
    if (diff.action === 'addElement') {
        var snippet = mdHTML(serializeNodeObj(diff.element));
        return "HTML has an unexpected element\n" + snippet;
    }
    else if (diff.action === 'removeElement') {
        var snippet = mdHTML(serializeNodeObj(diff.element));
        return "HTML is missing the expected element\n" + snippet;
    }
    else if (diff.action === 'removeAttribute') {
        var node = routeToNode(actualDoc, diff.route) || '???';
        var attr = diff.name + "=\"" + diff.value + "\"";
        var snippet = mdHTML(node.outerHTML || node.toString());
        return "HTML is missing the attribute `" + attr + "` on the element\n" + snippet;
    }
    else if (diff.action === 'replaceElement') {
        var eSnippet = mdHTML(serializeNodeObj(diff.oldValue));
        var aSnippept = mdHTML(serializeNodeObj(diff.newValue));
        return "HTML expected element\n" + eSnippet + "\nbut got element\n" + aSnippept;
    }
    else if (diff.action === 'modifyAttribute') {
        var node = routeToNode(expectedDoc, diff.route) || '???';
        var htmlSnippet = mdHTML(node.outerHTML || node.toString());
        var eSnippet = diff.oldValue;
        var aSnippet = diff.newValue;
        return "HTML mismatch on attribute `" + diff.name + "` in element\n" + htmlSnippet + "\n" +
            ("Expected\n" + eSnippet + "\nbut got\n" + aSnippet);
    }
    else if (diff.action === 'addTextElement') {
        return "HTML has an unexpected text\n" + diff.value;
    }
    else if (diff.action === 'removeTextElement') {
        return "HTML is missing the expected text\n" + diff.value;
    }
    else if (diff.action === 'modifyTextElement') {
        var eSnippet = diff.oldValue;
        var aSnippet = diff.newValue;
        return "HTML text mismatch. Expected\n" + eSnippet + "\nbut got\n" + aSnippet;
    }
    else {
        return "renderMismatch(" + JSON.stringify(diff) + ")";
    }
}
function reportMismatches(diffs, actualDoc, expectedDoc) {
    var msg = diffs
        .map(function (d) { return renderMismatch(d, actualDoc, expectedDoc); })
        .join('\n\n');
    throw new Error(msg);
}
exports.reportMismatches = reportMismatches;
//# sourceMappingURL=report.js.map